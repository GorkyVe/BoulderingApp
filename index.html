<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Boulder Tracker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #1e293b 0%, #7e22ce 50%, #1e293b 100%);
            color: white;
            min-height: 100vh;
            padding: 1rem;
            overflow-x: hidden;
        }

        .container {
            max-width: 640px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 1.5rem;
        }

        .header h1 {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .header p {
            color: #d1d5db;
        }

        .card {
            background: rgba(30, 41, 59, 0.65);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(148, 163, 184, 0.4);
            border-radius: 1rem;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 15px 45px rgba(0, 0, 0, 0.3);
        }

        .card.highlight {
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: linear-gradient(145deg, rgba(76, 29, 149, 0.85), rgba(30, 41, 59, 0.85));
        }

        .text-input {
            width: 100%;
            padding: 0.75rem 0.75rem;
            border-radius: 0.5rem;
            border: 1px solid rgba(148, 163, 184, 0.5);
            background: rgba(15, 23, 42, 0.6);
            color: white;
            font-size: 1rem;
        }

        .btn {
            width: 100%;
            padding: 1rem 1.5rem;
            font-size: 1.125rem;
            font-weight: bold;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-start {
            background: #16a34a;
            color: white;
        }

        .btn-start:hover {
            background: #15803d;
        }

        .btn-stop {
            background: #dc2626;
            color: white;
        }

        .btn-stop:hover {
            background: #b91c1c;
        }

        .alert {
            padding: 1rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
        }

        .alert-error {
            background: rgba(220, 38, 38, 0.3);
            border: 1px solid #dc2626;
        }

        .alert-warning {
            background: rgba(234, 179, 8, 0.3);
            border: 1px solid #eab308;
        }

        .metric {
            text-align: center;
            margin-bottom: 1rem;
        }

        .metric-value {
            font-size: 2rem;
            font-weight: bold;
            color: #10b981;
        }

        .metric-label {
            font-size: 0.875rem;
            color: #9ca3af;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 0.5rem;
        }

        .status-resting {
            background: #3b82f6;
        }

        .status-climbing {
            background: #eab308;
            animation: pulse 1s infinite;
        }

        .status-landing {
            background: #ef4444;
            animation: pulse 0.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .graph-container {
            display: flex;
            justify-content: center;
            margin: 1rem 0;
        }

        .graph-note {
            font-size: 0.75rem;
            color: #9ca3af;
            text-align: center;
            margin-top: 0.5rem;
        }

        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            z-index: 50;
        }

        .modal-content {
            background: #1e293b;
            border: 1px solid #475569;
            border-radius: 1rem;
            padding: 1.5rem;
            max-width: 400px;
            width: 100%;
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 1rem;
        }

        .modal-force {
            font-size: 2.5rem;
            font-weight: bold;
            color: #fbbf24;
            margin-bottom: 0.5rem;
        }

        .climb-duration {
            font-size: 1rem;
            color: #9ca3af;
            margin-bottom: 1rem;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-label {
            display: block;
            font-size: 0.875rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .btn-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }

        .chip-row {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin: 0.5rem 0 0;
        }

        .chip {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.12);
            padding: 0.4rem 0.75rem;
            border-radius: 999px;
            font-size: 0.875rem;
            color: #e5e7eb;
        }

        .btn-success {
            background: #9333ea;
            color: white;
            padding: 0.75rem 1rem;
            border: none;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-success:hover {
            background: #7e22ce;
        }

        .btn-success.blue {
            background: #2563eb;
        }

        .btn-success.blue:hover {
            background: #1d4ed8;
        }

        .grade-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
        }

        .grade-option {
            position: relative;
        }

        .grade-input {
            position: absolute;
            opacity: 0;
        }

        .grade-label {
            display: block;
            background: #475569;
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            text-align: center;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .grade-input:checked + .grade-label {
            background: #16a34a;
        }

        .grade-label:hover {
            background: #334155;
        }

        .btn-cancel {
            background: #4b5563;
            color: white;
            margin-top: 0.5rem;
        }

        .btn-cancel:hover {
            background: #374151;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
        }

        .stat-value.blue { color: #3b82f6; }
        .stat-value.purple { color: #a855f7; }
        .stat-value.green { color: #10b981; }

        .stat-label {
            font-size: 0.875rem;
            color: #9ca3af;
        }

        .climb-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .climb-item {
            background: rgba(71, 85, 105, 0.5);
            border-radius: 0.5rem;
            padding: 1rem;
        }

        .climb-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }

        .climb-left {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .climb-icon {
            font-size: 1.5rem;
        }

        .climb-grade {
            font-weight: 600;
        }

        .climb-time {
            font-size: 0.75rem;
            color: #9ca3af;
        }

        .climb-stats {
            display: flex;
            gap: 1rem;
            font-size: 0.875rem;
        }

        .climb-stat {
            color: #9ca3af;
        }

        .climb-stat strong {
            color: white;
        }

        .section-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .pending-queue {
            background: rgba(234, 179, 8, 0.2);
            border: 1px solid #eab308;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .queue-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .queue-item:last-child {
            margin-bottom: 0;
        }

        .btn-grade {
            background: #eab308;
            color: black;
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
        }

        .btn-grade:hover {
            background: #ca8a04;
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>
                <span>üìä</span>
                Boulder Tracker
            </h1>
            <p>Dial in beta, track motion, and log every send.</p>
            <div class="chip-row">
                <div class="chip">‚ö° Auto & manual recording</div>
                <div class="chip">üïí Queue climbs for grading</div>
                <div class="chip">üì± Mobile-ready layout</div>
            </div>
        </div>

        <div id="permissionError" class="alert alert-error hidden">
            <p>Motion sensor access denied. Please enable in your browser settings.</p>
        </div>

        <div id="unsupportedError" class="alert alert-warning hidden">
            <p>Motion sensors not supported on this device.</p>
        </div>

        <div class="card highlight">
            <div class="section-title">
                <span>üéØ</span>
                Get ready to climb
                <button class="action-link" onclick="openSettings()">Detection Settings</button>
            </div>
            <p style="color: #e2e8f0; line-height: 1.4; margin-bottom: 1rem;">Keep this page open, hit Start Tracking, then jump into your next climb. We'll keep the screen awake and queue every attempt so you can grade later.</p>
            <div class="mode-toggle">
                <button id="autoModeBtn" class="mode-option active" onclick="setDetectionMode('auto')">Automatic detection</button>
                <button id="manualModeBtn" class="mode-option" onclick="setDetectionMode('manual')">Manual start / stop</button>
            </div>
            <div class="btn-grid">
                <button id="startBtn" class="btn btn-start">Start Tracking</button>
                <button id="stopBtn" class="btn btn-stop hidden">Stop Tracking</button>
            </div>
            <div id="manualControls" class="hidden">
                <div class="form-label" style="margin-top: 1rem;">Manual climb controls</div>
                <div class="btn-grid">
                    <button id="manualStartBtn" class="btn btn-secondary" onclick="manualStartClimb()">Start climb</button>
                    <button id="manualStopBtn" class="btn btn-success" onclick="manualStopClimb()">Finish climb</button>
                </div>
                <div class="manual-note">Use this mode when automatic motion detection isn't available. Tap start when you leave the ground and finish when you land.</div>
            </div>
        </div>

        <div id="liveMonitor" class="card hidden">
            <div class="section-title">
                <span>üìà</span>
                Live Motion
            </div>
            <div class="metric">
                <div style="margin-bottom: 0.5rem;">
                    <span id="statusIndicator" class="status-indicator status-resting"></span>
                    <span id="statusText" style="font-size: 1rem; color: #9ca3af;">Resting</span>
                </div>
                <div id="currentAccel" class="metric-value">0.0 m/s¬≤</div>
                <div class="metric-label">Current acceleration</div>
            </div>
            <div class="graph-container">
                <canvas id="accelGraph" width="300" height="100"></canvas>
            </div>
            <div id="graphNote" class="graph-note"></div>
        </div>

        <div class="card">
            <div class="section-title">
                <span>üöÄ</span>
                Session checklist
            </div>
            <ul style="color: #e5e7eb; line-height: 1.6; margin-left: 1rem;">
                <li>Allow motion access if prompted so we can capture acceleration data.</li>
                <li>Use <strong>Automatic</strong> for hands-free detection or <strong>Manual</strong> to mark takeoff/landing yourself.</li>
                <li>Every climb‚Äîauto or manual‚Äîlands in your queue for grading as Flash or Top.</li>
            </ul>
        </div>

        <div id="pendingQueue" class="card hidden">
            <div class="section-title">
                <span>‚è≥</span>
                Pending Climbs
            </div>
            <div id="queueList"></div>
        </div>

        <div id="statsCard" class="card hidden">
            <div class="section-title">
                <span>üìä</span>
                Session Stats
            </div>
            <div class="stats-grid">
                <div>
                    <div id="totalClimbs" class="stat-value blue">0</div>
                    <div class="stat-label">Total</div>
                </div>
                <div>
                    <div id="flashCount" class="stat-value purple">0</div>
                    <div class="stat-label">Flashes</div>
                </div>
                <div>
                    <div id="topCount" class="stat-value green">0</div>
                    <div class="stat-label">Tops</div>
                </div>
            </div>
        </div>

        <div id="historyCard" class="card hidden">
            <div class="section-title">
                <span>üèÜ</span>
                Climb History
            </div>
            <div id="climbList" class="climb-list"></div>
        </div>
    </div>

    <div id="settingsModal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-title">Detection Settings</div>
            <div class="form-group">
                <label class="form-label">Rest threshold (m/s¬≤)</label>
                <input id="restThresholdInput" type="number" step="0.1" min="0" class="text-input" value="5">
            </div>
            <div class="form-group">
                <label class="form-label">Movement threshold (m/s¬≤)</label>
                <input id="movementThresholdInput" type="number" step="0.1" min="0" class="text-input" value="6">
            </div>
            <div class="form-group">
                <label class="form-label">Landing threshold (m/s¬≤)</label>
                <input id="landingThresholdInput" type="number" step="0.1" min="0" class="text-input" value="20">
            </div>
            <div class="form-group">
                <label class="form-label">Prime/finish rest duration (minutes)</label>
                <input id="restDurationInput" type="number" step="0.05" min="0" class="text-input" value="0.05">
            </div>
            <div class="form-group">
                <label class="form-label">Minimum climb duration (minutes)</label>
                <input id="minDurationInput" type="number" step="0.05" min="0" class="text-input" value="0.1">
            </div>
            <div class="form-group">
                <label class="form-label">Guided calibration</label>
                <div style="display: flex; gap: 0.5rem; align-items: center;">
                    <button class="btn btn-secondary" onclick="openCalibration()">Run calibration</button>
                    <div id="calibrationSummary" class="graph-note" style="margin: 0;">Use three sample climbs to tune thresholds.</div>
                </div>
            </div>
            <div class="btn-grid">
                <button class="btn btn-success" onclick="applySettings()">Save settings</button>
                <button class="btn btn-cancel" onclick="closeSettings()">Close</button>
            </div>
        </div>
    </div>

    <div id="calibrationModal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-title">Guided Calibration</div>
            <p class="graph-note" style="margin-bottom: 1rem;">We'll capture three climbs to recommend rest and landing thresholds.</p>
            <div id="calibrationStepsList" class="climb-list" style="gap: 0.75rem;"></div>
            <div class="graph-note" id="calibrationStatus" style="margin-top: 0.5rem;"></div>
            <div id="calibrationResults" class="graph-note" style="margin-top: 0.5rem;"></div>
            <div class="btn-grid" style="margin-top: 1rem;">
                <button id="startCalibrationBtn" class="btn btn-start" onclick="startCalibrationGuide()">Start calibration</button>
                <button id="stepActionBtn" class="btn btn-secondary" onclick="toggleCalibrationStep()" disabled>Record climb</button>
                <button class="btn btn-cancel" onclick="closeCalibration()">Close</button>
            </div>
        </div>
    </div>

    <div id="logModal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-title">Grade Your Climb! üéØ</div>
            <div class="metric">
                <div id="peakForce" class="modal-force">0.0 m/s¬≤</div>
                <div class="metric-label">Peak impact</div>
            </div>
            <div class="climb-duration" id="climbDuration">Duration: 0s</div>
            
            <div class="graph-container">
                <canvas id="climbGraph" width="300" height="80"></canvas>
            </div>
            <div class="graph-note" style="margin-bottom: 1rem;">Movement profile during climb</div>

            <div class="form-group">
                <label class="form-label">Success Type</label>
                <div class="btn-grid">
                    <button class="btn-success" onclick="setSuccessType('flash')">‚ö° Flash</button>
                    <button class="btn-success blue" onclick="setSuccessType('top')">üèîÔ∏è Top</button>
                </div>
            </div>

            <div class="form-group">
                <label class="form-label">Grade</label>
                <div class="grade-grid">
                    <div class="grade-option">
                        <input type="radio" name="grade" value="3" id="grade3" class="grade-input">
                        <label for="grade3" class="grade-label">3</label>
                    </div>
                    <div class="grade-option">
                        <input type="radio" name="grade" value="4" id="grade4" class="grade-input">
                        <label for="grade4" class="grade-label">4</label>
                    </div>
                    <div class="grade-option">
                        <input type="radio" name="grade" value="5" id="grade5" class="grade-input">
                        <label for="grade5" class="grade-label">5</label>
                    </div>
                    <div class="grade-option">
                        <input type="radio" name="grade" value="6a" id="grade6a" class="grade-input">
                        <label for="grade6a" class="grade-label">6a</label>
                    </div>
                    <div class="grade-option">
                        <input type="radio" name="grade" value="6b" id="grade6b" class="grade-input">
                        <label for="grade6b" class="grade-label">6b</label>
                    </div>
                    <div class="grade-option">
                        <input type="radio" name="grade" value="6c" id="grade6c" class="grade-input">
                        <label for="grade6c" class="grade-label">6c</label>
                    </div>
                    <div class="grade-option">
                        <input type="radio" name="grade" value="7a" id="grade7a" class="grade-input">
                        <label for="grade7a" class="grade-label">7a</label>
                    </div>
                    <div class="grade-option">
                        <input type="radio" name="grade" value="7b" id="grade7b" class="grade-input">
                        <label for="grade7b" class="grade-label">7b</label>
                    </div>
                </div>
            </div>

            <button class="btn btn-start" onclick="saveClimb()">Save Climb</button>
            <button class="btn btn-cancel" onclick="cancelLog()">Skip</button>
        </div>
    </div>

    <script>
        let isTracking = false;
        let currentAccel = 0;
        let accelHistory = [];
        let climbs = [];
        let pendingClimbs = [];
        let currentClimbData = null;
        let selectedSuccessType = null;

        // Climb detection state
        let climbState = 'resting'; // 'resting', 'climbing', 'landing'
        let climbStartTime = null;
        let climbMotionData = [];
        let restStartTime = null;
        let peakClimbForce = 0;
        let restPrimeStart = null;
        let wakeLock = null;
        let detectionMode = 'auto';
        let manualClimbStart = null;
        let manualMotionData = [];
        let manualPeakForce = 0;

        // Thresholds
        let REST_THRESHOLD = 5;
        let MOVEMENT_THRESHOLD = 6;
        let LANDING_THRESHOLD = 20;
        let REST_DURATION = 3000; // default 0.05 minutes
        let MIN_CLIMB_DURATION = 6000; // default 0.1 minutes
        const HISTORY_LENGTH = 50;

        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const liveMonitor = document.getElementById('liveMonitor');
        const logModal = document.getElementById('logModal');
        const graphNote = document.getElementById('graphNote');
        const manualControls = document.getElementById('manualControls');
        const settingsModal = document.getElementById('settingsModal');
        const autoModeBtn = document.getElementById('autoModeBtn');
        const manualModeBtn = document.getElementById('manualModeBtn');
        const canvas = document.getElementById('accelGraph');
        const ctx = canvas.getContext('2d');
        const climbCanvas = document.getElementById('climbGraph');
        const climbCtx = climbCanvas.getContext('2d');

        function syncThresholdsFromInputs() {
            REST_THRESHOLD = Number(document.getElementById('restThresholdInput').value) || REST_THRESHOLD;
            MOVEMENT_THRESHOLD = Number(document.getElementById('movementThresholdInput').value) || MOVEMENT_THRESHOLD;
            LANDING_THRESHOLD = Number(document.getElementById('landingThresholdInput').value) || LANDING_THRESHOLD;
            const restMinutes = Number(document.getElementById('restDurationInput').value);
            const minMinutes = Number(document.getElementById('minDurationInput').value);

            if (!Number.isNaN(restMinutes)) {
                REST_DURATION = restMinutes * 60000;
            }

            if (!Number.isNaN(minMinutes)) {
                MIN_CLIMB_DURATION = minMinutes * 60000;
            }

            updateGraphNote();
        }

        function applySettings() {
            syncThresholdsFromInputs();
            closeSettings();
        }

        function updateGraphNote() {
            if (detectionMode === 'manual') {
                graphNote.textContent = 'Manual control enabled ‚Äî automatic detection is paused.';
                return;
            }

            graphNote.textContent = `Blue = rest threshold (${REST_THRESHOLD} m/s¬≤) | Red = landing threshold (${LANDING_THRESHOLD} m/s¬≤)`;
        }

        function setDetectionMode(mode) {
            if (detectionMode !== mode && isTracking) {
                stopTracking();
            }

            detectionMode = mode;
            autoModeBtn.classList.toggle('active', mode === 'auto');
            manualModeBtn.classList.toggle('active', mode === 'manual');

            if (mode === 'manual') {
                liveMonitor.classList.add('hidden');
                if (isTracking) {
                    manualControls.classList.remove('hidden');
                }
            } else {
                manualControls.classList.add('hidden');
                if (isTracking) {
                    liveMonitor.classList.remove('hidden');
                }
            }

            updateGraphNote();
        }

        function openSettings() {
            settingsModal.classList.remove('hidden');
        }

        function closeSettings() {
            settingsModal.classList.add('hidden');
        }

        async function requestWakeLock() {
            if (!('wakeLock' in navigator)) return;

            try {
                wakeLock = await navigator.wakeLock.request('screen');
                wakeLock.addEventListener('release', () => {
                    wakeLock = null;
                });
            } catch (err) {
                console.warn('Wake lock not available', err);
            }
        }

        function releaseWakeLock() {
            if (wakeLock) {
                wakeLock.release();
                wakeLock = null;
            }
        }

        async function requestMotionPermission() {
            if (typeof DeviceMotionEvent === 'undefined') {
                document.getElementById('unsupportedError').classList.remove('hidden');
                return false;
            }

            if (typeof DeviceMotionEvent.requestPermission === 'function') {
                try {
                    const response = await DeviceMotionEvent.requestPermission();
                    if (response === 'granted') {
                        return true;
                    }
                    document.getElementById('permissionError').classList.remove('hidden');
                    return false;
                } catch (error) {
                    console.error('Permission error:', error);
                    document.getElementById('permissionError').classList.remove('hidden');
                    return false;
                }
            }

            return true;
        }

        async function startTracking() {
            if (detectionMode === 'manual') {
                await beginManualTracking();
                return;
            }

            const permissionGranted = await requestMotionPermission();
            if (!permissionGranted) return;

            await beginAutoTracking();
        }

        async function beginAutoTracking() {
            isTracking = true;
            accelHistory = [];
            climbState = 'resting';
            restPrimeStart = null;
            manualClimbStart = null;
            startBtn.classList.add('hidden');
            stopBtn.classList.remove('hidden');
            liveMonitor.classList.remove('hidden');
            manualControls.classList.add('hidden');

            await requestWakeLock();

            window.addEventListener('devicemotion', handleMotion);
        }

        async function beginManualTracking() {
            await requestMotionPermission();
            await requestWakeLock();
            isTracking = true;
            climbState = 'resting';
            manualClimbStart = null;
            manualMotionData = [];
            manualPeakForce = 0;
            startBtn.classList.add('hidden');
            stopBtn.classList.remove('hidden');
            manualControls.classList.remove('hidden');
            liveMonitor.classList.add('hidden');
            updateGraphNote();
            window.addEventListener('devicemotion', handleManualMotion);
        }

        function stopTracking() {
            isTracking = false;
            window.removeEventListener('devicemotion', handleMotion);
            window.removeEventListener('devicemotion', handleManualMotion);
            startBtn.classList.remove('hidden');
            stopBtn.classList.add('hidden');
            liveMonitor.classList.add('hidden');
            manualControls.classList.add('hidden');
            currentAccel = 0;
            climbState = 'resting';
            restPrimeStart = null;
            manualClimbStart = null;
            manualMotionData = [];
            releaseWakeLock();
        }

        function manualStartClimb() {
            if (!isTracking || detectionMode !== 'manual') return;
            if (manualClimbStart) return;

            manualClimbStart = Date.now();
            climbState = 'climbing';
            updateStatusUI('climbing');
        }

        function manualStopClimb() {
            if (!isTracking || detectionMode !== 'manual') return;
            if (!manualClimbStart) return;

            const duration = Date.now() - manualClimbStart;
            const climb = {
                id: Date.now(),
                timestamp: new Date(),
                duration: duration,
                peakForce: manualMotionData.length ? manualPeakForce.toFixed(1) : 'Manual',
                motionData: [...manualMotionData],
                manual: true
            };

            pendingClimbs.push(climb);
            manualClimbStart = null;
            manualMotionData = [];
            manualPeakForce = 0;
            climbState = 'resting';
            updatePendingQueue();
            updateStatusUI('resting');
        }

        function handleManualMotion(event) {
            if (!manualClimbStart) return;
            const acc = event.acceleration || event.accelerationIncludingGravity;
            if (!acc) return;

            const x = acc.x || 0;
            const y = acc.y || 0;
            const z = acc.z || 0;

            const totalAccel = Math.sqrt(x * x + y * y + z * z);
            manualMotionData.push(totalAccel);
            manualPeakForce = Math.max(manualPeakForce, totalAccel);
        }

        function handleMotion(event) {
            const acc = event.acceleration || event.accelerationIncludingGravity;
            if (!acc) return;

            const x = acc.x || 0;
            const y = acc.y || 0;
            const z = acc.z || 0;

            const totalAccel = Math.sqrt(x * x + y * y + z * z);
            currentAccel = totalAccel;

            document.getElementById('currentAccel').textContent = totalAccel.toFixed(1) + ' m/s¬≤';

            accelHistory.push(totalAccel);
            if (accelHistory.length > HISTORY_LENGTH) {
                accelHistory.shift();
            }

            drawGraph();
            updateClimbState(totalAccel);
        }

        function startClimb(now, accel) {
            climbState = 'climbing';
            climbStartTime = now;
            climbMotionData = [accel];
            peakClimbForce = accel;
            restStartTime = null;
            restPrimeStart = null;
            updateStatusUI('climbing');
        }

        function updateClimbState(accel) {
            const now = Date.now();

            if (climbState === 'resting') {
                if (accel <= REST_THRESHOLD) {
                    if (!restPrimeStart) {
                        restPrimeStart = now;
                    }
                }

                const restedLongEnough = restPrimeStart && (now - restPrimeStart >= REST_DURATION);
                if (restedLongEnough && accel > MOVEMENT_THRESHOLD) {
                    startClimb(now, accel);
                } else if (accel > MOVEMENT_THRESHOLD && !restedLongEnough) {
                    restPrimeStart = null;
                }
            }
            else if (climbState === 'climbing') {
                climbMotionData.push(accel);
                peakClimbForce = Math.max(peakClimbForce, accel);

                if (accel > LANDING_THRESHOLD) {
                    climbState = 'landing';
                    restStartTime = now;
                    updateStatusUI('landing');
                }
                else if (accel <= REST_THRESHOLD) {
                    if (!restStartTime) {
                        restStartTime = now;
                    } else if (now - restStartTime >= REST_DURATION) {
                        // Climb completed
                        const duration = now - climbStartTime;
                        if (duration >= MIN_CLIMB_DURATION) {
                            completeClimb(duration);
                        }
                        climbState = 'resting';
                        restStartTime = null;
                        updateStatusUI('resting');
                    }
                } else {
                    restStartTime = null; // Reset if movement detected
                }
            }
            else if (climbState === 'landing') {
                climbMotionData.push(accel);
                peakClimbForce = Math.max(peakClimbForce, accel);

                if (accel <= REST_THRESHOLD) {
                    if (!restStartTime) {
                        restStartTime = now;
                    } else if (now - restStartTime >= REST_DURATION) {
                        // Climb completed with landing
                        const duration = now - climbStartTime;
                        if (duration >= MIN_CLIMB_DURATION) {
                            completeClimb(duration);
                        }
                        climbState = 'resting';
                        restStartTime = null;
                        updateStatusUI('resting');
                    }
                } else {
                    restStartTime = null;
                }
            }
        }

        function updateStatusUI(state) {
            const indicator = document.getElementById('statusIndicator');
            const text = document.getElementById('statusText');
            
            indicator.className = 'status-indicator';
            
            if (state === 'resting') {
                indicator.classList.add('status-resting');
                text.textContent = 'Resting';
            } else if (state === 'climbing') {
                indicator.classList.add('status-climbing');
                text.textContent = 'Climbing...';
            } else if (state === 'landing') {
                indicator.classList.add('status-landing');
                text.textContent = 'Landing Detected!';
            }
        }

        function completeClimb(duration) {
            const climb = {
                id: Date.now(),
                timestamp: new Date(),
                duration: duration,
                peakForce: peakClimbForce.toFixed(1),
                motionData: [...climbMotionData],
                manual: false
            };

            pendingClimbs.push(climb);
            climbMotionData = [];
            peakClimbForce = 0;
            
            updatePendingQueue();
        }

        function updatePendingQueue() {
            const queueCard = document.getElementById('pendingQueue');
            const queueList = document.getElementById('queueList');
            
            if (pendingClimbs.length === 0) {
                queueCard.classList.add('hidden');
                return;
            }

            queueCard.classList.remove('hidden');
            queueList.innerHTML = '';

            pendingClimbs.forEach((climb, index) => {
                const item = document.createElement('div');
                item.className = 'queue-item';

                const durationSec = (climb.duration / 1000).toFixed(0);
                const peakDisplay = climb.peakForce === 'Manual' ? 'Manual entry' : `${climb.peakForce} m/s¬≤`;
                const typeLabel = climb.manual ? 'Manual' : 'Auto';
                const info = document.createElement('div');
                const title = document.createElement('div');
                title.style.fontWeight = '600';
                title.textContent = `Climb #${pendingClimbs.length - index}`;

                const meta = document.createElement('div');
                meta.style.fontSize = '0.875rem';
                meta.style.color = '#9ca3af';
                meta.textContent = `${durationSec}s ¬∑ Peak: ${peakDisplay} ¬∑ ${typeLabel}`;

                const miniGraph = document.createElement('canvas');
                miniGraph.width = 140;
                miniGraph.height = 50;
                miniGraph.style.marginTop = '0.5rem';

                info.appendChild(title);
                info.appendChild(meta);
                info.appendChild(miniGraph);

                const actions = document.createElement('div');
                actions.style.display = 'flex';
                actions.style.alignItems = 'center';
                actions.style.gap = '0.5rem';

                const gradeBtn = document.createElement('button');
                gradeBtn.className = 'btn-grade';
                gradeBtn.textContent = 'Grade Now';
                gradeBtn.onclick = () => gradeClimb(index);

                actions.appendChild(gradeBtn);

                item.appendChild(info);
                item.appendChild(actions);

                queueList.appendChild(item);
                drawPendingGraph(miniGraph, climb.motionData);
            });
        }

        function drawPendingGraph(canvasEl, data) {
            const miniCtx = canvasEl.getContext('2d');
            miniCtx.fillStyle = '#0f172a';
            miniCtx.fillRect(0, 0, canvasEl.width, canvasEl.height);

            if (data.length < 2) return;

            const maxVal = Math.max(...data, 1);

            miniCtx.strokeStyle = '#a855f7';
            miniCtx.lineWidth = 2;
            miniCtx.beginPath();

            data.forEach((val, i) => {
                const x = (i / data.length) * canvasEl.width;
                const y = canvasEl.height - (val / maxVal) * canvasEl.height;

                if (i === 0) {
                    miniCtx.moveTo(x, y);
                } else {
                    miniCtx.lineTo(x, y);
                }
            });

            miniCtx.stroke();
        }

        function gradeClimb(index) {
            const climb = pendingClimbs[index];
            if (!climb) return;

            currentClimbData = { ...climb, index };
            selectedSuccessType = null;

            const peakValue = climb.peakForce === 'Manual' ? 'Manual entry' : `${climb.peakForce} m/s¬≤`;
            document.getElementById('peakForce').textContent = peakValue;
            document.getElementById('climbDuration').textContent =
                `Duration: ${(climb.duration / 1000).toFixed(0)}s`;

            drawClimbGraph(climb.motionData);
            logModal.classList.remove('hidden');
        }

        function drawClimbGraph(data) {
            climbCtx.fillStyle = '#111827';
            climbCtx.fillRect(0, 0, climbCanvas.width, climbCanvas.height);

            if (data.length < 2) return;

            const maxVal = Math.max(...data, 1);
            
            climbCtx.strokeStyle = '#10b981';
            climbCtx.lineWidth = 2;
            climbCtx.beginPath();

            data.forEach((val, i) => {
                const x = (i / data.length) * climbCanvas.width;
                const y = climbCanvas.height - (val / maxVal) * climbCanvas.height;

                if (i === 0) {
                    climbCtx.moveTo(x, y);
                } else {
                    climbCtx.lineTo(x, y);
                }
            });

            climbCtx.stroke();
        }

        function drawGraph() {
            ctx.fillStyle = '#111827';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const maxVal = Math.max(...accelHistory, LANDING_THRESHOLD);
            
            // Draw thresholds
            const restY = canvas.height - (REST_THRESHOLD / maxVal) * canvas.height;
            const landingY = canvas.height - (LANDING_THRESHOLD / maxVal) * canvas.height;

            ctx.strokeStyle = '#3b82f6';
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            ctx.moveTo(0, restY);
            ctx.lineTo(canvas.width, restY);
            ctx.stroke();

            ctx.strokeStyle = '#ef4444';
            ctx.beginPath();
            ctx.moveTo(0, landingY);
            ctx.lineTo(canvas.width, landingY);
            ctx.stroke();
            ctx.setLineDash([]);

            if (accelHistory.length > 1) {
                ctx.strokeStyle = '#10b981';
                ctx.lineWidth = 2;
                ctx.beginPath();

                accelHistory.forEach((val, i) => {
                    const x = (i / HISTORY_LENGTH) * canvas.width;
                    const y = canvas.height - (val / maxVal) * canvas.height;

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });

                ctx.stroke();
            }
        }

        function setSuccessType(type) {
            selectedSuccessType = type;
        }

        function saveClimb() {
            if (!currentClimbData) return;
            
            if (!selectedSuccessType) {
                alert('Please select Flash or Top');
                return;
            }

            const gradeInput = document.querySelector('input[name="grade"]:checked');
            if (!gradeInput) {
                alert('Please select a grade');
                return;
            }

            const climb = {
                id: currentClimbData.id,
                timestamp: currentClimbData.timestamp,
                duration: currentClimbData.duration,
                success: selectedSuccessType,
                grade: gradeInput.value,
                force: currentClimbData.peakForce
            };

            climbs.unshift(climb);
            pendingClimbs.splice(currentClimbData.index, 1);
            
            updateUI();
            updatePendingQueue();
            cancelLog();
        }

        function cancelLog() {
            logModal.classList.add('hidden');
            currentClimbData = null;
            selectedSuccessType = null;
            const gradeInputs = document.querySelectorAll('input[name="grade"]');
            gradeInputs.forEach(input => input.checked = false);
        }


        function updateUI() {
            const total = climbs.length;
            const flashes = climbs.filter(c => c.success === 'flash').length;
            const tops = climbs.filter(c => c.success === 'top').length;

            document.getElementById('totalClimbs').textContent = total;
            document.getElementById('flashCount').textContent = flashes;
            document.getElementById('topCount').textContent = tops;

            if (total > 0) {
                document.getElementById('statsCard').classList.remove('hidden');
                document.getElementById('historyCard').classList.remove('hidden');
            }

            const climbList = document.getElementById('climbList');
            climbList.innerHTML = '';

            climbs.forEach(climb => {
                const item = document.createElement('div');
                item.className = 'climb-item';

                const icon = climb.success === 'flash' ? '‚ö°' : 'üèîÔ∏è';
                const time = new Date(climb.timestamp).toLocaleTimeString();
                const durationSec = (climb.duration / 1000).toFixed(0);
                const peakText = climb.force === 'Manual' ? 'Manual' : `${climb.force} m/s¬≤ peak`;

                item.innerHTML = `
                    <div class="climb-header">
                        <div class="climb-left">
                            <div class="climb-icon">${icon}</div>
                            <div>
                                <div class="climb-grade">V${climb.grade}</div>
                                <div class="climb-time">${time}</div>
                            </div>
                        </div>
                        <div class="climb-grade">${climb.success === 'flash' ? 'Flash' : 'Top'}</div>
                    </div>
                    <div class="climb-stats">
                        <div class="climb-stat"><strong>${durationSec}s</strong> time</div>
                        <div class="climb-stat"><strong>${peakText}</strong></div>
                        <div class="climb-stat"><strong>V${climb.grade}</strong> grade</div>
                    </div>
                `;

                climbList.appendChild(item);
            });
        }

        startBtn.addEventListener('click', startTracking);
        stopBtn.addEventListener('click', stopTracking);

        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible' && isTracking) {
                requestWakeLock();
            } else if (!isTracking) {
                releaseWakeLock();
            }
        });

        window.addEventListener('beforeunload', releaseWakeLock);

        // Calibration
        const calibrationSteps = [
            {
                id: 'slow-soft',
                title: 'Slow up, slow down',
                description: 'Climb gently and step down softly to capture relaxed motion.'
            },
            {
                id: 'hard-soft',
                title: 'Hard up, slow down',
                description: 'Explode upward, then control your landing.'
            },
            {
                id: 'hard-hard',
                title: 'Hard up, hard down',
                description: 'Powerful pull and firmer jump down to log a strong landing.'
            }
        ];

        let calibrationIndex = 0;
        let calibrationActive = false;
        let calibrationRecording = false;
        let calibrationSamples = [];
        let calibrationResultsData = [];

        const calibrationModal = document.getElementById('calibrationModal');
        const calibrationStatus = document.getElementById('calibrationStatus');
        const calibrationResults = document.getElementById('calibrationResults');
        const calibrationStepsList = document.getElementById('calibrationStepsList');
        const startCalibrationBtn = document.getElementById('startCalibrationBtn');
        const stepActionBtn = document.getElementById('stepActionBtn');
        const calibrationSummary = document.getElementById('calibrationSummary');

        function openCalibration() {
            if (isTracking) {
                stopTracking();
            }

            calibrationModal.classList.remove('hidden');
            resetCalibrationState();
        }

        function closeCalibration() {
            calibrationModal.classList.add('hidden');
            stopCalibrationCapture();
        }

        function resetCalibrationState() {
            calibrationIndex = 0;
            calibrationActive = false;
            calibrationRecording = false;
            calibrationSamples = [];
            calibrationResultsData = [];
            calibrationStatus.textContent = 'Press start to begin capturing climbs.';
            calibrationResults.textContent = '';
            startCalibrationBtn.disabled = false;
            stepActionBtn.disabled = true;
            stepActionBtn.textContent = 'Record climb';
            renderCalibrationSteps();
        }

        function renderCalibrationSteps() {
            calibrationStepsList.innerHTML = '';

            calibrationSteps.forEach((step, index) => {
                const item = document.createElement('div');
                item.className = 'climb-item';
                item.style.padding = '0.75rem';

                const status = document.createElement('div');
                status.className = 'climb-header';

                const left = document.createElement('div');
                left.className = 'climb-left';
                const icon = document.createElement('div');
                icon.className = 'climb-icon';
                icon.textContent = index === calibrationIndex && calibrationRecording ? '‚è∫Ô∏è' : 'üéØ';
                const metaWrap = document.createElement('div');
                const title = document.createElement('div');
                title.className = 'climb-grade';
                title.textContent = step.title;
                const desc = document.createElement('div');
                desc.className = 'climb-time';
                desc.textContent = step.description;
                metaWrap.appendChild(title);
                metaWrap.appendChild(desc);
                left.appendChild(icon);
                left.appendChild(metaWrap);

                const badge = document.createElement('div');
                badge.className = 'climb-grade';
                if (calibrationResultsData[index]) {
                    badge.textContent = `${calibrationResultsData[index].peak.toFixed(1)} m/s¬≤`;
                } else if (index === calibrationIndex && calibrationActive) {
                    badge.textContent = calibrationRecording ? 'Recording...' : 'Ready';
                } else {
                    badge.textContent = 'Pending';
                }

                status.appendChild(left);
                status.appendChild(badge);
                item.appendChild(status);
                calibrationStepsList.appendChild(item);
            });
        }

        function stopCalibrationCapture() {
            calibrationRecording = false;
            calibrationActive = false;
            window.removeEventListener('devicemotion', handleCalibrationMotion);
        }

        async function startCalibrationGuide() {
            const permissionGranted = await requestMotionPermission();
            if (!permissionGranted) return;

            calibrationActive = true;
            calibrationIndex = 0;
            calibrationResultsData = [];
            calibrationStatus.textContent = 'Follow each step and tap "Record climb" before you move.';
            startCalibrationBtn.disabled = true;
            stepActionBtn.disabled = false;
            stepActionBtn.textContent = 'Record climb';
            calibrationSummary.textContent = 'Calibrating... perform each climb when prompted.';
            window.addEventListener('devicemotion', handleCalibrationMotion);
            renderCalibrationSteps();
        }

        function handleCalibrationMotion(event) {
            if (!calibrationRecording) return;
            const acc = event.acceleration || event.accelerationIncludingGravity;
            if (!acc) return;

            const totalAccel = Math.sqrt((acc.x || 0) ** 2 + (acc.y || 0) ** 2 + (acc.z || 0) ** 2);
            calibrationSamples.push(totalAccel);
        }

        function toggleCalibrationStep() {
            if (!calibrationActive) return;

            if (!calibrationRecording) {
                calibrationSamples = [];
                calibrationRecording = true;
                calibrationStatus.textContent = `Recording: ${calibrationSteps[calibrationIndex].title}. Perform the climb, then tap again to finish.`;
                stepActionBtn.textContent = 'Finish step';
            } else {
                calibrationRecording = false;
                stepActionBtn.textContent = 'Record climb';
                processCalibrationStep();
            }

            renderCalibrationSteps();
        }

        function processCalibrationStep() {
            if (calibrationSamples.length === 0) {
                calibrationStatus.textContent = 'No motion detected. Please retry this step.';
                return;
            }

            const peak = Math.max(...calibrationSamples);
            const average = calibrationSamples.reduce((a, b) => a + b, 0) / calibrationSamples.length;
            calibrationResultsData[calibrationIndex] = { peak, average };
            calibrationStatus.textContent = `${calibrationSteps[calibrationIndex].title} captured. Peak ${peak.toFixed(1)} m/s¬≤.`;

            calibrationIndex += 1;
            if (calibrationIndex >= calibrationSteps.length) {
                finishCalibration();
                return;
            }

            calibrationStatus.textContent += ' Start the next climb when ready.';
            renderCalibrationSteps();
        }

        function finishCalibration() {
            calibrationActive = false;
            calibrationRecording = false;
            stepActionBtn.disabled = true;
            startCalibrationBtn.disabled = false;
            window.removeEventListener('devicemotion', handleCalibrationMotion);

            if (calibrationResultsData.length < calibrationSteps.length) {
                calibrationStatus.textContent = 'Calibration incomplete. Capture all three climbs to generate recommendations.';
                return;
            }

            const recommendations = generateCalibrationRecommendations();
            const resultText = calibrationResultsData
                .map((result, idx) => `${calibrationSteps[idx].title}: peak ${result.peak.toFixed(1)} m/s¬≤`)
                .join(' ¬∑ ');

            calibrationResults.textContent = resultText;
            calibrationStatus.textContent = 'Recommendations applied to detection settings.';
            calibrationSummary.textContent = `Rest ${recommendations.rest} | Movement ${recommendations.movement} | Landing ${recommendations.landing} m/s¬≤`;
            applyCalibrationRecommendations(recommendations);
            renderCalibrationSteps();
        }

        function generateCalibrationRecommendations() {
            const slowPeak = calibrationResultsData[0].peak;
            const hardSlowPeak = calibrationResultsData[1].peak;
            const hardHardPeak = calibrationResultsData[2].peak;

            const rest = Number(Math.max(3, slowPeak * 0.35).toFixed(1));
            const movement = Number((((slowPeak + hardSlowPeak) / 2) * 0.75).toFixed(1));
            const landing = Number((Math.max(hardSlowPeak, hardHardPeak) * 0.85).toFixed(1));

            return { rest, movement, landing };
        }

        function applyCalibrationRecommendations(recommendations) {
            document.getElementById('restThresholdInput').value = recommendations.rest;
            document.getElementById('movementThresholdInput').value = recommendations.movement;
            document.getElementById('landingThresholdInput').value = recommendations.landing;

            syncThresholdsFromInputs();
        }

        setDetectionMode('auto');
        applySettings();
    </script>

</body>

</html>
