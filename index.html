<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Boulder Tracker</title>
    <style>
        :root {
            color-scheme: dark;
            --bg: #212529;
            --panel: #343a40;
            --muted: #adb5bd;
            --primary: #f8f9fa;
            --accent: #ff6b6b;
            --warning: #fcc419;
            --danger: #e03131;
            --border: #495057;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            min-height: 100vh;
            background: radial-gradient(circle at 20% 20%, rgba(52, 58, 64, 0.2), transparent 35%),
                        radial-gradient(circle at 80% 0%, rgba(52, 58, 64, 0.2), transparent 30%),
                        var(--bg);
            color: #e2e8f0;
            font-family: "Inter", system-ui, -apple-system, sans-serif;
            padding: 1.5rem 1rem 2.5rem;
        }

        .container {
            max-width: 760px;
            margin: 0 auto;
            display: grid;
            gap: 1rem;
        }

        header h1 {
            margin: 0;
            font-size: 1.6rem;
            font-weight: 800;
        }

        header p {
            margin: 0.3rem 0 0;
            color: var(--muted);
            line-height: 1.5;
        }

        .card {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 1rem 1.25rem;
            box-shadow: 0 18px 30px rgba(0, 0, 0, 0.25);
        }

        .row {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex-wrap: wrap;
        }

        .btn {
            appearance: none;
            border: none;
            border-radius: 12px;
            padding: 0.8rem 1.1rem;
            font-weight: 700;
            color: #0b1220;
            cursor: pointer;
            transition: transform 0.1s ease, box-shadow 0.1s ease;
        }

        .btn-small { padding: 0.55rem 0.85rem; font-size: 0.9rem; }

        .btn-danger { background: var(--danger); color: #0b1220; box-shadow: 0 10px 24px rgba(248, 113, 113, 0.3); }

        .btn:active { transform: translateY(1px); }

        .btn-start { background: linear-gradient(135deg, #22d3ee, #34d399); box-shadow: 0 12px 30px rgba(52, 211, 153, 0.3); }
        .btn-stop { background: linear-gradient(135deg, #f59e0b, #ef4444); color: #0b1220; box-shadow: 0 12px 30px rgba(239, 68, 68, 0.35); }
        .btn-secondary { background: #1f2937; color: #e5e7eb; box-shadow: inset 0 0 0 1px #334155; }

        .status {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            background: rgba(52, 211, 153, 0.1);
            color: #bbf7d0;
            border-radius: 999px;
            padding: 0.35rem 0.7rem;
            font-size: 0.85rem;
            font-weight: 700;
            letter-spacing: 0.02em;
        }

        .status.stopped { background: rgba(148, 163, 184, 0.12); color: var(--muted); }

        .info-text { color: var(--muted); font-size: 0.95rem; line-height: 1.5; }

        .stat-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 0.75rem;
        }

        .stat {
            background: #0d1727;
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 0.75rem 0.9rem;
        }

        .stat .label { color: var(--muted); font-size: 0.9rem; }
        .stat .value { font-size: 1.6rem; font-weight: 800; margin-top: 0.15rem; }

        .reading {
            font-size: 2.4rem;
            font-weight: 900;
            letter-spacing: -0.02em;
        }

        .pill {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.4rem 0.75rem;
            border-radius: 999px;
            background: #0d1727;
            border: 1px solid var(--border);
            color: var(--muted);
            font-weight: 600;
        }

        canvas {
            width: 100%;
            background: #0d1727;
            border-radius: 12px;
            border: 1px solid var(--border);
        }

        #accelGraph { height: 140px; }
        .impact-graph { height: 80px; width: 100%; }

        .legend { display: flex; gap: 0.75rem; color: var(--muted); flex-wrap: wrap; font-size: 0.9rem; }
        .legend span { display: inline-flex; align-items: center; gap: 0.35rem; }
        .legend .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }

        .climb-meta { display: grid; gap: 0.5rem; margin-top: 0.75rem; }
        .climb-meta .meta-row { display: flex; align-items: center; justify-content: space-between; gap: 0.75rem; flex-wrap: wrap; }
        .climb-meta .label { color: var(--muted); font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.05em; }
        .climb-meta .value { font-weight: 800; font-size: 1.1rem; }
        .status-pill { padding: 0.45rem 0.8rem; border-radius: 999px; font-weight: 800; letter-spacing: 0.02em; }
        .status-pill.resting { background: rgba(148, 163, 184, 0.12); color: var(--muted); border: 1px solid var(--border); }
        .status-pill.climbing { background: rgba(52, 211, 153, 0.15); color: #bbf7d0; border: 1px solid rgba(52, 211, 153, 0.4); }

        .list { display: grid; gap: 0.75rem; }
        .item {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 1rem;
            align-items: center;
            padding: 0.85rem 1rem;
            border-radius: 12px;
            background: #0d1727;
            border: 1px solid var(--border);
        }

        .item-content {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            min-width: 0;
        }

        .item .impact-graph-container {
            max-width: 150px;
            width: 30vw;
        }

        .item .meta { color: var(--muted); font-size: 0.9rem; }
        .item .force { font-weight: 800; color: var(--warning); }

        .badge { padding: 0.25rem 0.6rem; border-radius: 10px; font-weight: 700; font-size: 0.85rem; border: 1px solid var(--border); }
        .badge.flash { color: #c4b5fd; background: rgba(196, 181, 253, 0.12); border-color: rgba(196, 181, 253, 0.35); }
        .badge.top { color: #86efac; background: rgba(134, 239, 172, 0.12); border-color: rgba(134, 239, 172, 0.35); }
        .badge.queued { color: var(--muted); background: rgba(148, 163, 184, 0.12); }

        .alert {
            border-radius: 12px;
            padding: 0.85rem 1rem;
            font-weight: 600;
            margin: 0.5rem 0;
        }

        .alert.error { background: rgba(248, 113, 113, 0.15); border: 1px solid rgba(248, 113, 113, 0.4); }
        .alert.warn { background: rgba(245, 158, 11, 0.12); border: 1px solid rgba(245, 158, 11, 0.35); }

        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.65);
            display: grid;
            place-items: center;
            padding: 1.25rem;
            z-index: 50;
        }

        .modal-content {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 1.25rem;
            max-width: 420px;
            width: 100%;
            box-shadow: 0 18px 30px rgba(0, 0, 0, 0.35);
        }

        .grade-grid {
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr));
            gap: 0.5rem;
        }

        .grade-option { position: relative; }
        .grade-input { position: absolute; opacity: 0; }

        .grade-label {
            display: block;
            padding: 0.55rem 0.5rem;
            text-align: center;
            border-radius: 10px;
            background: #1f2937;
            border: 1px solid var(--border);
            font-weight: 700;
            cursor: pointer;
            color: #e5e7eb;
        }

        .grade-input:checked + .grade-label { background: #22d3ee; color: #0b1220; border-color: #22d3ee; }

        .flex-between { display: flex; align-items: center; justify-content: space-between; gap: 0.75rem; }
        .hidden { display: none; }

        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 0.75rem;
            margin-top: 0.75rem;
        }

        .settings-field {
            display: grid;
            gap: 0.35rem;
        }

        .settings-field input {
            width: 100%;
            padding: 0.6rem 0.7rem;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: #0d1727;
            color: #e2e8f0;
            font-weight: 700;
        }

        @media (max-width: 360px) {
            .item {
                grid-template-columns: 1fr;
            }
            .item .impact-graph-container {
                width: 100%;
                max-width: none;
                margin-top: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="flex-between">
            <div>
                <h1>Boulder Tracker</h1>
                <p class="info-text" style="margin: 0.25rem 0 0;">Automatic and manual climb tracking.</p>
            </div>
            <button id="settingsBtn" class="btn btn-secondary" style="padding: 0.6rem;">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 0 2l-.15.08a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.38a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1 0-2l.15-.08a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path>
                    <circle cx="12" cy="12" r="3"></circle>
                </svg>
            </button>
        </header>

        <div id="permissionError" class="alert error hidden">Motion sensor access denied. Enable it in your browser settings.</div>
        <div id="unsupportedError" class="alert warn hidden">This device does not report motion data.</div>

        <div class="card">
            <div class="row" style="justify-content: center;">
                <button id="autoClimbBtn" class="btn btn-start">Start Automatic Detection</button>
                <button id="manualClimbBtn" class="btn btn-secondary">Start Manual Climb</button>
            </div>
        </div>

        <div id="liveMonitor" class="card hidden">
            <div class="flex-between">
                <div>
                    <div class="label" style="color: var(--muted); text-transform: uppercase; letter-spacing: 0.08em; font-size: 0.8rem;">Current acceleration</div>
                    <div id="currentAccel" class="reading">0.0 m/s²</div>
                </div>
                <span class="pill">Tracking force</span>
            </div>
            <div style="margin: 1rem 0 0.75rem;">
                <canvas id="accelGraph" width="600" height="140"></canvas>
            </div>
            <div class="legend">
                <span><span class="dot" style="background:#f97316;"></span><span id="restLegend">Rest ~2</span></span>
                <span><span class="dot" style="background:#38bdf8;"></span><span id="climbLegend">Climb ~8</span></span>
                <span><span class="dot" style="background:#ef4444;"></span><span id="landingLegend">Landing ≥ 15</span></span>
            </div>
            <div class="climb-meta">
                <div class="meta-row">
                    <div>
                        <div class="label">Logging</div>
                        <div id="climbNumber" class="value">—</div>
                    </div>
                    <div>
                        <div class="label">Start time</div>
                        <div id="climbStartTime" class="value" style="color: var(--muted);">—</div>
                    </div>
                </div>
                <div class="meta-row">
                    <span id="restingBadge" class="status-pill resting">Resting</span>
                    <span id="climbingBadge" class="status-pill climbing hidden">Climbing</span>
                </div>
            </div>
        </div>


        <div class="card">
            <div class="stat-grid">
                <div class="stat">
                    <div class="label">Total climbs</div>
                    <div id="totalClimbs" class="value">0</div>
                </div>
                <div class="stat">
                    <div class="label">Flashes</div>
                    <div id="flashCount" class="value">0</div>
                </div>
                <div class="stat">
                    <div class="label">Tops</div>
                    <div id="topCount" class="value">0</div>
                </div>
            </div>
        </div>

        <div id="historyCard" class="card">
            <div class="flex-between" style="margin-bottom: 0.5rem;">
                <h3 style="margin: 0;">Climb queue</h3>
                <div class="row" style="gap:0.4rem; flex-wrap: nowrap;">
                    <span id="queueInfo" class="pill">No climbs yet</span>
                </div>
            </div>
            <div id="climbList" class="list"></div>
        </div>
    </div>

    <div id="settingsModal" class="modal hidden">
        <div class="modal-content">
            <div class="flex-between" style="margin-bottom: 0.75rem;">
                <h3 style="margin: 0;">Settings</h3>
                <button id="closeSettingsBtn" class="btn btn-secondary">Close</button>
            </div>
            <p class="info-text">Tune the sensitivity of the resting, climbing, and landing detection thresholds (m/s²).</p>
            <div class="settings-grid">
                <label class="settings-field">
                    <span class="label" style="color: var(--muted);">Rest threshold</span>
                    <input id="restThresholdInput" type="number" step="0.1" min="0" value="2">
                </label>
                <label class="settings-field">
                    <span class="label" style="color: var(--muted);">Climb threshold</span>
                    <input id="climbThresholdInput" type="number" step="0.1" min="0" value="8">
                </label>
                <label class="settings-field">
                    <span class="label" style="color: var(--muted);">Fall threshold</span>
                    <input id="landingThresholdInput" type="number" step="0.1" min="0" value="15">
                </label>
            </div>
        </div>
    </div>

    <div id="logModal" class="modal hidden">
        <div class="modal-content">
            <div class="flex-between" style="margin-bottom: 0.5rem;">
                <h3 style="margin: 0;">Grade this climb</h3>
                <button class="btn btn-secondary" onclick="cancelLog()">Close</button>
            </div>
            <p class="info-text">Captured landing force</p>
            <div id="peakForce" class="reading" style="margin: 0.25rem 0 0.75rem;">0.0 m/s²</div>

            <div style="display: grid; gap: 0.5rem;">
                <div>
                    <div class="label" style="color: var(--muted); margin-bottom: 0.35rem;">Success type</div>
                    <div class="row">
                        <button class="btn btn-secondary" onclick="logClimb('flash')">Flash</button>
                        <button class="btn btn-secondary" onclick="logClimb('top')">Top</button>
                    </div>
                </div>

                <div>
                    <div class="label" style="color: var(--muted); margin-bottom: 0.35rem;">Grade</div>
                    <div class="grade-grid">
                        <div class="grade-option">
                            <input type="radio" name="grade" value="3" id="grade3" class="grade-input">
                            <label for="grade3" class="grade-label">3</label>
                        </div>
                        <div class="grade-option">
                            <input type="radio" name="grade" value="4" id="grade4" class="grade-input">
                            <label for="grade4" class="grade-label">4</label>
                        </div>
                        <div class="grade-option">
                            <input type="radio" name="grade" value="5" id="grade5" class="grade-input">
                            <label for="grade5" class="grade-label">5</label>
                        </div>
                        <div class="grade-option">
                            <input type="radio" name="grade" value="6a" id="grade6a" class="grade-input">
                            <label for="grade6a" class="grade-label">6a</label>
                        </div>
                        <div class="grade-option">
                            <input type="radio" name="grade" value="6b" id="grade6b" class="grade-input">
                            <label for="grade6b" class="grade-label">6b</label>
                        </div>
                        <div class="grade-option">
                            <input type="radio" name="grade" value="6c" id="grade6c" class="grade-input">
                            <label for="grade6c" class="grade-label">6c</label>
                        </div>
                        <div class="grade-option">
                            <input type="radio" name="grade" value="7a" id="grade7a" class="grade-input">
                            <label for="grade7a" class="grade-label">7a</label>
                        </div>
                        <div class="grade-option">
                            <input type="radio" name="grade" value="7b" id="grade7b" class="grade-input">
                            <label for="grade7b" class="grade-label">7b</label>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let isTracking = false;
        let currentAccel = 0;
        let peakForce = 0;
        let accelHistory = [];
        let climbs = [];
        let cooldown = false;
        let wakeLock = null;
        let currentClimbId = null;
        let inClimb = false;
        let currentClimb = null;
        let manualClimbInProgress = false;

        const GRAVITY = 9.81;
        let restThreshold = 2;
        let climbThreshold = 8;
        let landingThreshold = 15;
        const HISTORY_LENGTH = 60;

        const liveMonitor = document.getElementById('liveMonitor');
        const logModal = document.getElementById('logModal');
        const canvas = document.getElementById('accelGraph');
        const ctx = canvas.getContext('2d');
        const climbNumberEl = document.getElementById('climbNumber');
        const climbStartTimeEl = document.getElementById('climbStartTime');
        const restingBadge = document.getElementById('restingBadge');
        const climbingBadge = document.getElementById('climbingBadge');
        const restInput = document.getElementById('restThresholdInput');
        const climbInput = document.getElementById('climbThresholdInput');
        const landingInput = document.getElementById('landingThresholdInput');
        const restLegend = document.getElementById('restLegend');
        const climbLegend = document.getElementById('climbLegend');
        const landingLegend = document.getElementById('landingLegend');

        function computeAccel(event) {
            const linear = event.acceleration;
            if (linear && [linear.x, linear.y, linear.z].some(v => v !== null)) {
                const x = linear.x || 0;
                const y = linear.y || 0;
                const z = linear.z || 0;
                return Math.sqrt(x * x + y * y + z * z);
            }

            const gravitySource = event.accelerationIncludingGravity;
            if (!gravitySource) return null;

            const gx = gravitySource.x || 0;
            const gy = gravitySource.y || 0;
            const gz = gravitySource.z || 0;
            const magnitude = Math.sqrt(gx * gx + gy * gy + gz * gz);
            return Math.max(0, magnitude - GRAVITY);
        }

        const TIME_FORMAT = { hour12: false, hour: '2-digit', minute: '2-digit' };

        function formatTime(date) {
            if (!date) return '—';
            return date.toLocaleTimeString([], TIME_FORMAT);
        }

        function formatDuration(startTime, endTime) {
            if (!startTime || !endTime) return '—';
            const duration = Math.abs(endTime - startTime) / 1000;
            const minutes = Math.floor(duration / 60);
            const seconds = Math.floor(duration % 60);

            if (minutes > 0) {
                return `${minutes}m ${seconds}s`;
            }
            return `${seconds}s`;
        }

        function formatForce(value) {
            const rounded = Math.round(Number(value) || 0);
            return `${rounded} m/s²`;
        }

        function clampThreshold(value, fallback) {
            const parsed = parseFloat(value);
            if (!Number.isFinite(parsed) || parsed < 0) return fallback;
            return parsed;
        }

        function updateThresholdDisplays() {
            if (restLegend) restLegend.textContent = `Rest ~${restThreshold}`;
            if (climbLegend) climbLegend.textContent = `Climb ~${climbThreshold}`;
            if (landingLegend) landingLegend.textContent = `Landing ≥ ${landingThreshold}`;

            if (restInput) restInput.value = restThreshold;
            if (climbInput) climbInput.value = climbThreshold;
            if (landingInput) landingInput.value = landingThreshold;
        }

        function handleThresholdChange() {
            restThreshold = clampThreshold(restInput?.value, restThreshold);
            climbThreshold = clampThreshold(climbInput?.value, climbThreshold);
            landingThreshold = clampThreshold(landingInput?.value, landingThreshold);

            updateThresholdDisplays();
            drawGraph();
            updateUI();
        }

        async function startTracking() {
            if (isTracking) return;

            if (typeof DeviceMotionEvent !== 'undefined') {
                if (typeof DeviceMotionEvent.requestPermission === 'function') {
                    try {
                        const response = await DeviceMotionEvent.requestPermission();
                        if (response === 'granted') {
                            await beginTracking();
                        } else {
                            document.getElementById('permissionError').classList.remove('hidden');
                        }
                    } catch (error) {
                        console.error('Permission error:', error);
                        document.getElementById('permissionError').classList.remove('hidden');
                    }
                } else {
                    await beginTracking();
                }
            } else {
                document.getElementById('unsupportedError').classList.remove('hidden');
            }
        }

        async function beginTracking(source = 'auto') {
            isTracking = true;
            accelHistory = [];
            inClimb = false;
            currentClimb = null;
            updateClimbMeta();

            const autoClimbBtn = document.getElementById('autoClimbBtn');
            autoClimbBtn.textContent = 'Stop Automatic Detection';
            autoClimbBtn.classList.remove('btn-start');
            autoClimbBtn.classList.add('btn-stop');
            if (source === 'auto') {
                document.getElementById('manualClimbBtn').classList.add('hidden');
            }

            liveMonitor.classList.remove('hidden');

            try {
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                }
            } catch (err) {
                console.log('Wake lock not supported or failed:', err);
            }

            window.addEventListener('devicemotion', handleMotion);
        }

        function stopTracking() {
            if (!isTracking) return;

            isTracking = false;
            window.removeEventListener('devicemotion', handleMotion);

            if (inClimb) {
                completeClimb();
            }

            if (wakeLock) {
                wakeLock.release().then(() => { wakeLock = null; });
            }

            inClimb = false;
            currentClimb = null;
            manualClimbInProgress = false;
            updateClimbMeta();

            liveMonitor.classList.add('hidden');
            document.querySelector('.legend').classList.remove('hidden');

            const autoClimbBtn = document.getElementById('autoClimbBtn');
            autoClimbBtn.textContent = 'Start Automatic Detection';
            autoClimbBtn.classList.add('btn-start');
            autoClimbBtn.classList.remove('btn-stop');
            document.getElementById('manualClimbBtn').classList.remove('hidden');

            currentAccel = 0;
        }

        function handleMotion(event) {
            if (!isTracking) return;

            const totalAccel = computeAccel(event);
            if (totalAccel === null) return;

            currentAccel = totalAccel;
            document.getElementById('currentAccel').textContent = formatForce(totalAccel);

            accelHistory.push(totalAccel);
            if (accelHistory.length > HISTORY_LENGTH) {
                accelHistory.shift();
            }

            drawGraph(manualClimbInProgress);

            if (inClimb) {
                trackClimbSample(totalAccel);
            }

            if (manualClimbInProgress) {
                return;
            }

            if (!inClimb && totalAccel >= climbThreshold && !cooldown) {
                startClimb();
            } else if (inClimb && totalAccel >= landingThreshold && !cooldown) {
                completeClimb();
            }
        }

        function updateClimbMeta() {
            if (!climbNumberEl || !climbStartTimeEl) return;

            const nextClimbNumber = climbs.length + 1;
            climbNumberEl.textContent = isTracking ? `#${nextClimbNumber}` : '—';

            const startTimeText = inClimb && currentClimb && currentClimb.startTime ? formatTime(currentClimb.startTime) : '—';
            climbStartTimeEl.textContent = startTimeText;

            if (inClimb) {
                climbingBadge.classList.remove('hidden');
                restingBadge.classList.add('hidden');
            } else {
                restingBadge.classList.remove('hidden');
                climbingBadge.classList.add('hidden');
            }
        }

        function startClimb() {
            inClimb = true;
            const climbStart = new Date();
            currentClimb = {
                id: Date.now(),
                timestamp: climbStart,
                startTime: climbStart,
                endTime: null,
                success: null,
                grade: null,
                force: 0,
                samples: []
            };

            currentClimbId = currentClimb.id;
            updateClimbMeta();
        }

        function trackClimbSample(value) {
            if (!currentClimb) return;
            currentClimb.force = Math.max(currentClimb.force, value);
            currentClimb.samples.push(value);

            if (currentClimb.samples.length > HISTORY_LENGTH) {
                currentClimb.samples.shift();
            }
        }

        function completeClimb() {
            if (!currentClimb) return;

            if (manualClimbInProgress) {
                manualClimbInProgress = false;
                const manualClimbBtn = document.getElementById('manualClimbBtn');
                manualClimbBtn.textContent = 'Start Manual Climb';
                manualClimbBtn.classList.remove('btn-danger');
            }

            cooldown = true;
            inClimb = false;
            currentClimb.endTime = new Date();
            const roundedForce = Math.round(currentClimb.force);
            currentClimb.force = roundedForce;
            peakForce = roundedForce;
            climbs.unshift(currentClimb);
            updateUI();
            updateClimbMeta();

            setTimeout(() => {
                cooldown = false;
            }, 2500);

            currentClimb = null;
        }

        function startManualClimb() {
            if (inClimb) return;

            if (!isTracking) {
                // Silently start tracking if it's not already active
                beginTracking('manual').then(() => {
                    manualClimbInProgress = true;
                    startClimb();
                });
            } else {
                manualClimbInProgress = true;
                startClimb();
            }

            const manualClimbBtn = document.getElementById('manualClimbBtn');
            manualClimbBtn.textContent = 'End Manual Climb';
            manualClimbBtn.classList.add('btn-danger');
            document.getElementById('autoClimbBtn').classList.add('hidden');
            document.querySelector('.legend').classList.add('hidden');
        }

        function endManualClimb() {
            if (!isTracking || !inClimb) return;
            completeClimb();
            document.getElementById('autoClimbBtn').classList.remove('hidden');
            document.querySelector('.legend').classList.remove('hidden');
        }

        function drawGraph(isManualMode = false) {
            ctx.fillStyle = '#0b1220';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const maxVal = Math.max(...accelHistory, landingThreshold);
            if (!isManualMode) {
                const thresholds = [
                    { value: restThreshold, color: '#f97316' },
                    { value: climbThreshold, color: '#38bdf8' },
                    { value: landingThreshold, color: '#ef4444', dashed: true }
                ];

                thresholds.forEach(threshold => {
                    const y = canvas.height - (threshold.value / maxVal) * canvas.height;
                    ctx.strokeStyle = threshold.color;
                    ctx.setLineDash(threshold.dashed ? [4, 4] : [2, 4]);
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                });
                ctx.setLineDash([]);
            }

            if (accelHistory.length > 1) {
                ctx.strokeStyle = '#34d399';
                ctx.lineWidth = 2;
                ctx.beginPath();

                accelHistory.forEach((val, i) => {
                    const x = (i / HISTORY_LENGTH) * canvas.width;
                    const y = canvas.height - (val / maxVal) * canvas.height;

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });

                ctx.stroke();
            }
        }

        function renderImpactGraph(targetCanvas, samples = [], force = 0) {
            if (!targetCanvas) return;

            const localCtx = targetCanvas.getContext('2d');
            const width = targetCanvas.clientWidth || targetCanvas.width;
            const height = targetCanvas.clientHeight || targetCanvas.height || 80;
            if (width) targetCanvas.width = width;
            if (height) targetCanvas.height = height;

            const drawWidth = targetCanvas.width;
            const drawHeight = targetCanvas.height;

            localCtx.fillStyle = '#0d1727';
            localCtx.fillRect(0, 0, drawWidth, drawHeight);

            if (!samples.length) return;

            const dataMax = Math.max(...samples);
            const dataMin = Math.min(...samples);

            let minVal = dataMin;
            let maxVal = dataMax;

            if (maxVal === minVal) {
                minVal -= 1;
                maxVal += 1;
            } else {
                const padding = (maxVal - minVal) * 0.1;
                minVal -= padding;
                maxVal += padding;
            }
            const range = maxVal - minVal;

            const stepX = drawWidth / Math.max(samples.length - 1, 1);

            localCtx.strokeStyle = '#ef4444';
            localCtx.setLineDash([4, 4]);
            const landingY = drawHeight - ((landingThreshold - minVal) / range) * drawHeight;
            localCtx.beginPath();
            localCtx.moveTo(0, landingY);
            localCtx.lineTo(targetCanvas.width, landingY);
            localCtx.stroke();
            localCtx.setLineDash([]);

            localCtx.strokeStyle = '#38bdf8';
            localCtx.lineWidth = 2;
            localCtx.beginPath();

            samples.forEach((value, index) => {
                const x = index * stepX;
                const y = drawHeight - ((value - minVal) / range) * drawHeight;

                if (index === 0) {
                    localCtx.moveTo(x, y);
                } else {
                    localCtx.lineTo(x, y);
                }
            });

            localCtx.stroke();

            const peakValue = Math.max(...samples);
            const peakIndex = samples.lastIndexOf(peakValue);
            const peakX = peakIndex * stepX;
            const peakY = drawHeight - ((peakValue - minVal) / range) * drawHeight;

            localCtx.fillStyle = '#f59e0b';
            localCtx.beginPath();
            localCtx.arc(peakX, peakY, 4, 0, Math.PI * 2);
            localCtx.fill();
        }

        function showLogModal(climb = null) {
            const forceValue = climb ? climb.force : peakForce;
            document.getElementById('peakForce').textContent = formatForce(forceValue);
            logModal.classList.remove('hidden');
        }

        function gradeClimb(id) {
            const climb = climbs.find(c => c.id === id);
            if (!climb) return;

            currentClimbId = climb.id;
            peakForce = climb.force;
            showLogModal(climb);
        }

        function logClimb(success) {
            const gradeInput = document.querySelector('input[name="grade"]:checked');
            if (!gradeInput) {
                alert('Please select a grade');
                return;
            }

            const climb = climbs.find(c => c.id === currentClimbId);
            if (!climb) {
                alert('No climb selected to grade.');
                return;
            }

            climb.success = success;
            climb.grade = gradeInput.value;
            climb.force = Number(climb.force);

            updateUI();
            cancelLog();
        }

        function cancelLog() {
            logModal.classList.add('hidden');
            const gradeInputs = document.querySelectorAll('input[name="grade"]');
            gradeInputs.forEach(input => input.checked = false);
            currentClimbId = null;
        }

        function deleteClimb(id) {
            climbs = climbs.filter(c => c.id !== id);
            updateUI();
        }

        function updateUI() {
            const total = climbs.length;
            const flashes = climbs.filter(c => c.success === 'flash').length;
            const tops = climbs.filter(c => c.success === 'top').length;
            const queued = climbs.filter(c => !c.success || !c.grade).length;

            document.getElementById('totalClimbs').textContent = total;
            document.getElementById('flashCount').textContent = flashes;
            document.getElementById('topCount').textContent = tops;

            const queueInfo = document.getElementById('queueInfo');
            if (queued > 0) {
                queueInfo.textContent = `${queued} queued`;
            } else if (total > 0) {
                queueInfo.textContent = 'All graded';
            } else {
                queueInfo.textContent = 'No climbs yet';
            }

            const climbList = document.getElementById('climbList');
            climbList.innerHTML = '';

            climbs.forEach(climb => {
                const item = document.createElement('div');
                item.className = 'item card';

                const isGraded = climb.success && climb.grade;
                const label = isGraded ? (climb.success === 'flash' ? 'Flash' : 'Top') : 'Ungraded';
                const badgeClass = isGraded ? (climb.success === 'flash' ? 'flash' : 'top') : 'queued';
                const gradeText = isGraded ? `${climb.grade}` : '';
                const startTimeText = formatTime(climb.startTime);
                const durationText = formatDuration(climb.startTime, climb.endTime);
                const forceText = formatForce(climb.force);
                const graphId = `impact-${climb.id}`;

                item.innerHTML = `
                    <div class="item-content">
                        <div class="flex-between">
                             <div class="row">
                                <span class="badge ${badgeClass}">${label}</span>
                                ${isGraded ? `<span class="badge">${gradeText}</span>` : ''}
                            </div>
                            <div class="meta">${startTimeText}</div>
                        </div>
                        <div class="flex-between" style="align-items: flex-end;">
                             <div>
                                <div class="force" style="font-size: 1.5rem;">${forceText}</div>
                                <div class="meta">Peak Force</div>
                            </div>
                            <div class="meta">~${durationText}</div>
                        </div>
                         <div class="row" style="margin-top: 0.5rem;">
                            ${!isGraded ? `<button class="btn btn-secondary btn-small grade-btn">Grade</button>` : ''}
                            <button class="btn btn-danger btn-small delete-btn">Delete</button>
                        </div>
                    </div>
                    <div class="impact-graph-container">
                        <canvas class="impact-graph" id="${graphId}"></canvas>
                    </div>
                `;

                if (!isGraded) {
                    item.querySelector('.grade-btn').addEventListener('click', () => gradeClimb(climb.id));
                }
                item.querySelector('.delete-btn').addEventListener('click', () => deleteClimb(climb.id));

                climbList.appendChild(item);
                const graphCanvas = item.querySelector(`#${graphId}`);
                renderImpactGraph(graphCanvas, climb.samples || [climb.force], climb.force);
            });

            updateClimbMeta();
        }

        updateClimbMeta();

        [restInput, climbInput, landingInput].forEach(input => {
            if (input) {
                input.addEventListener('change', handleThresholdChange);
                input.addEventListener('blur', handleThresholdChange);
            }
        });

        updateThresholdDisplays();

        const autoClimbBtn = document.getElementById('autoClimbBtn');
        autoClimbBtn.addEventListener('click', () => {
            if (isTracking) {
                stopTracking();
            } else {
                startTracking();
            }
        });

        const manualClimbBtn = document.getElementById('manualClimbBtn');
        manualClimbBtn.addEventListener('click', () => {
            if (manualClimbInProgress) {
                endManualClimb();
            } else {
                startManualClimb();
            }
        });

        const settingsModal = document.getElementById('settingsModal');
        const settingsBtn = document.getElementById('settingsBtn');
        const closeSettingsBtn = document.getElementById('closeSettingsBtn');

        settingsBtn.addEventListener('click', () => {
            settingsModal.classList.remove('hidden');
        });

        closeSettingsBtn.addEventListener('click', () => {
            settingsModal.classList.add('hidden');
        });

        document.addEventListener('visibilitychange', async () => {
            if (document.visibilityState === 'visible' && isTracking && !wakeLock) {
                try {
                    if ('wakeLock' in navigator) {
                        wakeLock = await navigator.wakeLock.request('screen');
                    }
                } catch (err) {
                    console.log('Failed to re-acquire wake lock:', err);
                }
            }
        });
    </script>
</body>
</html>
